/* automatically generated by rust-bindgen 0.69.1 */

extern crate libc;
use libc::in_addr;
use libc::in6_addr;
use libc::sockaddr;
use libc::sockaddr_in;
use libc::sockaddr_in6;
use libc::timespec;

pub type wg_key = [u8; 32usize];
pub type wg_key_b64_string = [::core::ffi::c_char; 45usize];
#[repr(C)]
pub struct __BindgenUnionField<T>(::core::marker::PhantomData<T>);
#[doc = " Cross platform __kernel_timespec"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec64 {
    pub tv_sec: i64,
    pub tv_nsec: i64,
}
#[repr(C)]
pub struct wg_allowedip {
    pub family: u16,
    pub __bindgen_anon_1: wg_allowedip__bindgen_ty_1,
    pub cidr: u8,
    pub next_allowedip: *mut wg_allowedip,
}
#[repr(C)]
pub struct wg_allowedip__bindgen_ty_1 {
    pub ip4: __BindgenUnionField<in_addr>,
    pub ip6: __BindgenUnionField<in6_addr>,
    pub bindgen_union_field: [u32; 4usize],
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct wg_peer_flags(pub ::core::ffi::c_uint);
#[repr(C)]
pub struct wg_endpoint {
    pub addr: __BindgenUnionField<sockaddr>,
    pub addr4: __BindgenUnionField<sockaddr_in>,
    pub addr6: __BindgenUnionField<sockaddr_in6>,
    pub bindgen_union_field: [u32; 7usize],
}
#[repr(C)]
pub struct wg_peer {
    pub flags: wg_peer_flags,
    pub public_key: wg_key,
    pub preshared_key: wg_key,
    pub endpoint: wg_endpoint,
    pub last_handshake_time: timespec64,
    pub rx_bytes: u64,
    pub tx_bytes: u64,
    pub persistent_keepalive_interval: u16,
    pub first_allowedip: *mut wg_allowedip,
    pub last_allowedip: *mut wg_allowedip,
    pub next_peer: *mut wg_peer,
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct wg_device_flags(pub ::core::ffi::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct wg_device {
    pub name: [::core::ffi::c_char; 16usize],
    pub ifindex: u32,
    pub flags: wg_device_flags,
    pub public_key: wg_key,
    pub private_key: wg_key,
    pub fwmark: u32,
    pub listen_port: u16,
    pub first_peer: *mut wg_peer,
    pub last_peer: *mut wg_peer,
}
#[test]
fn bindgen_test_layout_timespec64() {
    const UNINIT: ::core::mem::MaybeUninit<timespec64> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<timespec64>(),
        16usize,
        concat!("Size of: ", stringify!(timespec64))
    );
    assert_eq!(
        ::core::mem::align_of::<timespec64>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec64))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec64),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec64),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[test]
fn bindgen_test_layout_wg_allowedip__bindgen_ty_1() {
    const UNINIT: ::core::mem::MaybeUninit<wg_allowedip__bindgen_ty_1> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<wg_allowedip__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(wg_allowedip__bindgen_ty_1))
    );
    assert_eq!(
        ::core::mem::align_of::<wg_allowedip__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wg_allowedip__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_allowedip__bindgen_ty_1),
            "::",
            stringify!(ip4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ip6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_allowedip__bindgen_ty_1),
            "::",
            stringify!(ip6)
        )
    );
}
#[test]
fn bindgen_test_layout_wg_allowedip() {
    const UNINIT: ::core::mem::MaybeUninit<wg_allowedip> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<wg_allowedip>(),
        32usize,
        concat!("Size of: ", stringify!(wg_allowedip))
    );
    assert_eq!(
        ::core::mem::align_of::<wg_allowedip>(),
        8usize,
        concat!("Alignment of ", stringify!(wg_allowedip))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).family) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_allowedip),
            "::",
            stringify!(family)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).cidr) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_allowedip),
            "::",
            stringify!(cidr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_allowedip) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_allowedip),
            "::",
            stringify!(next_allowedip)
        )
    );
}
#[test]
fn bindgen_test_layout_wg_endpoint() {
    const UNINIT: ::core::mem::MaybeUninit<wg_endpoint> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<wg_endpoint>(),
        28usize,
        concat!("Size of: ", stringify!(wg_endpoint))
    );
    assert_eq!(
        ::core::mem::align_of::<wg_endpoint>(),
        4usize,
        concat!("Alignment of ", stringify!(wg_endpoint))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_endpoint),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr4) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_endpoint),
            "::",
            stringify!(addr4)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).addr6) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_endpoint),
            "::",
            stringify!(addr6)
        )
    );
}
#[test]
fn bindgen_test_layout_wg_peer() {
    const UNINIT: ::core::mem::MaybeUninit<wg_peer> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<wg_peer>(),
        160usize,
        concat!("Size of: ", stringify!(wg_peer))
    );
    assert_eq!(
        ::core::mem::align_of::<wg_peer>(),
        8usize,
        concat!("Alignment of ", stringify!(wg_peer))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_peer),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).public_key) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_peer),
            "::",
            stringify!(public_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).preshared_key) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_peer),
            "::",
            stringify!(preshared_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).endpoint) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_peer),
            "::",
            stringify!(endpoint)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_handshake_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_peer),
            "::",
            stringify!(last_handshake_time)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).rx_bytes) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_peer),
            "::",
            stringify!(rx_bytes)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).tx_bytes) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_peer),
            "::",
            stringify!(tx_bytes)
        )
    );
    assert_eq!(
        unsafe {
            ::core::ptr::addr_of!((*ptr).persistent_keepalive_interval) as usize - ptr as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_peer),
            "::",
            stringify!(persistent_keepalive_interval)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).first_allowedip) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_peer),
            "::",
            stringify!(first_allowedip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_allowedip) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_peer),
            "::",
            stringify!(last_allowedip)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).next_peer) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_peer),
            "::",
            stringify!(next_peer)
        )
    );
}
#[test]
fn bindgen_test_layout_wg_device() {
    const UNINIT: ::core::mem::MaybeUninit<wg_device> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<wg_device>(),
        112usize,
        concat!("Size of: ", stringify!(wg_device))
    );
    assert_eq!(
        ::core::mem::align_of::<wg_device>(),
        8usize,
        concat!("Alignment of ", stringify!(wg_device))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_device),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).ifindex) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_device),
            "::",
            stringify!(ifindex)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_device),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).public_key) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_device),
            "::",
            stringify!(public_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).private_key) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_device),
            "::",
            stringify!(private_key)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).fwmark) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_device),
            "::",
            stringify!(fwmark)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).listen_port) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_device),
            "::",
            stringify!(listen_port)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).first_peer) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_device),
            "::",
            stringify!(first_peer)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).last_peer) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(wg_device),
            "::",
            stringify!(last_peer)
        )
    );
}
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::core::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        unsafe { ::core::mem::transmute(self) }
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        unsafe { ::core::mem::transmute(self) }
    }
}
impl<T> ::core::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::core::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        *self
    }
}
impl<T> ::core::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::core::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::core::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::core::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::core::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::core::cmp::Eq for __BindgenUnionField<T> {}
impl ::core::fmt::Debug for wg_allowedip__bindgen_ty_1 {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "wg_allowedip__bindgen_ty_1 {{ union }}")
    }
}
impl ::core::fmt::Debug for wg_allowedip {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(
            f,
            "wg_allowedip {{ __bindgen_anon_1: {:?}, next_allowedip: {:?} }}",
            self.__bindgen_anon_1, self.next_allowedip
        )
    }
}
impl wg_peer_flags {
    pub const WGPEER_REMOVE_ME: wg_peer_flags = wg_peer_flags(1);
}
impl wg_peer_flags {
    pub const WGPEER_REPLACE_ALLOWEDIPS: wg_peer_flags = wg_peer_flags(2);
}
impl wg_peer_flags {
    pub const WGPEER_HAS_PUBLIC_KEY: wg_peer_flags = wg_peer_flags(4);
}
impl wg_peer_flags {
    pub const WGPEER_HAS_PRESHARED_KEY: wg_peer_flags = wg_peer_flags(8);
}
impl wg_peer_flags {
    pub const WGPEER_HAS_PERSISTENT_KEEPALIVE_INTERVAL: wg_peer_flags = wg_peer_flags(16);
}
impl ::core::ops::BitOr<wg_peer_flags> for wg_peer_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        wg_peer_flags(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for wg_peer_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: wg_peer_flags) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<wg_peer_flags> for wg_peer_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        wg_peer_flags(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for wg_peer_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: wg_peer_flags) {
        self.0 &= rhs.0;
    }
}
impl ::core::fmt::Debug for wg_endpoint {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write!(f, "wg_endpoint {{ union }}")
    }
}
impl ::core::fmt::Debug for wg_peer {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        write ! (f , "wg_peer {{ flags: {:?}, public_key: {:?}, preshared_key: {:?}, endpoint: {:?}, last_handshake_time: {:?}, first_allowedip: {:?}, last_allowedip: {:?}, next_peer: {:?} }}" , self . flags , self . public_key , self . preshared_key , self . endpoint , self . last_handshake_time , self . first_allowedip , self . last_allowedip , self . next_peer)
    }
}
impl wg_device_flags {
    pub const WGDEVICE_REPLACE_PEERS: wg_device_flags = wg_device_flags(1);
}
impl wg_device_flags {
    pub const WGDEVICE_HAS_PRIVATE_KEY: wg_device_flags = wg_device_flags(2);
}
impl wg_device_flags {
    pub const WGDEVICE_HAS_PUBLIC_KEY: wg_device_flags = wg_device_flags(4);
}
impl wg_device_flags {
    pub const WGDEVICE_HAS_LISTEN_PORT: wg_device_flags = wg_device_flags(8);
}
impl wg_device_flags {
    pub const WGDEVICE_HAS_FWMARK: wg_device_flags = wg_device_flags(16);
}
impl ::core::ops::BitOr<wg_device_flags> for wg_device_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        wg_device_flags(self.0 | other.0)
    }
}
impl ::core::ops::BitOrAssign for wg_device_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: wg_device_flags) {
        self.0 |= rhs.0;
    }
}
impl ::core::ops::BitAnd<wg_device_flags> for wg_device_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        wg_device_flags(self.0 & other.0)
    }
}
impl ::core::ops::BitAndAssign for wg_device_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: wg_device_flags) {
        self.0 &= rhs.0;
    }
}
extern "C" {
    pub fn wg_set_device(dev: *mut wg_device) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn wg_get_device(
        dev: *mut *mut wg_device,
        device_name: *const ::core::ffi::c_char,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn wg_add_device(device_name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn wg_del_device(device_name: *const ::core::ffi::c_char) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn wg_free_device(dev: *mut wg_device);
}
extern "C" {
    pub fn wg_list_device_names() -> *mut ::core::ffi::c_char;
}
extern "C" {
    pub fn wg_key_to_base64(base64: *mut wg_key_b64_string, key: *mut wg_key);
}
extern "C" {
    pub fn wg_key_from_base64(
        key: *mut wg_key,
        base64: *mut wg_key_b64_string,
    ) -> ::core::ffi::c_int;
}
extern "C" {
    pub fn wg_key_is_zero(key: *mut wg_key) -> bool;
}
extern "C" {
    pub fn wg_generate_public_key(public_key: *mut wg_key, private_key: *mut wg_key);
}
extern "C" {
    pub fn wg_generate_private_key(private_key: *mut wg_key);
}
extern "C" {
    pub fn wg_generate_preshared_key(preshared_key: *mut wg_key);
}
